Prompt: Embed Backend Server into ClassicPOS Android APK (Offline Mode)

You are an AI full-stack Android and Node.js engineer.
Your task is to configure ClassicPOS so that the backend Express server runs inside the Android APK and serves both the frontend UI and API endpoints locally â€” without any external internet or LAN connection.
The app must work 100% offline using a local embedded database (SQLite).

ğŸ¯ Goal

Transform ClassicPOS into a self-contained Android APK that includes:

Express backend

SQLite database

React frontend (served by Express)

Localhost-based API (http://127.0.0.1
 or http://localhost
)

Optional: Auto-start backend when the app launches

ğŸ§± Architecture

Embedded Stack:

Android WebView (UI Layer)
   â†“
Embedded Node.js Runtime (e.g. JXcore / Node.js for Mobile Apps)
   â†“
Express.js API (serving React build + handling data)
   â†“
SQLite (local data store)

ğŸ§© Implementation Steps
1ï¸âƒ£ Add Node.js Runtime to Android

Use Node.js for Mobile Apps (or JXcore alternative):

Install package:

npm install nodejs-mobile-react-native --save


This provides a fully functional Node.js runtime that can execute your Express backend inside Android.

2ï¸âƒ£ Move your backend into a â€œmobile-serverâ€ folder

Structure:

classicpos/
â”œâ”€â”€ mobile-server/
â”‚   â”œâ”€â”€ index.js        (Express entry point)
â”‚   â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ db.sqlite
â”‚   â”œâ”€â”€ package.json

3ï¸âƒ£ Modify server startup (index.js)
const express = require('express');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();

const app = express();
const dbPath = path.join(__dirname, 'db.sqlite');
const db = new sqlite3.Database(dbPath);

app.use(express.json());
app.use('/api', require('./routes'));

const buildPath = path.join(__dirname, '../dist');
app.use(express.static(buildPath));

app.get('*', (req, res) => {
  res.sendFile(path.join(buildPath, 'index.html'));
});

app.listen(3001, () => console.log('Embedded ClassicPOS server running on port 3001'));

4ï¸âƒ£ Integrate Node.js runtime into React Native layer

In your React Native/Capacitor project:

import nodejs from 'nodejs-mobile-react-native';
import { useEffect } from 'react';

export default function App() {
  useEffect(() => {
    nodejs.start('mobile-server/index.js');
  }, []);

  return <WebView source={{ uri: 'http://127.0.0.1:3001' }} />;
}

5ï¸âƒ£ Serve React frontend through backend

Run:

npm run build


Then copy the generated /dist folder into mobile-server/ so Express can serve it offline.

6ï¸âƒ£ Bundle SQLite database

Place your SQLite .db file inside mobile-server/ (it will be accessed locally and writable).

7ï¸âƒ£ Build the APK

Use Capacitor or React Native to package the entire app:

npx cap sync android
npx cap open android


Then build the APK in Android Studio.

When the app starts, the backend server launches automatically, and the WebView connects to http://127.0.0.1:3001.

ğŸ§¾ Verification Checklist

 App launches without internet

 Express backend starts automatically

 WebView loads UI via localhost

 SQLite operations work offline

 Data persists between sessions

âš ï¸ Important Notes

Memory usage increases (~60â€“80 MB) since Node runs inside the APK.

Avoid using heavy dependencies like bcrypt; use lightweight crypto.

For syncing (optional), you can later add cloud sync endpoints when online.

ğŸš€ Optional Add-Ons

âœ… Auto-start backend on boot
âœ… Local backup system using device storage
âœ… Sync engine (upload local data to cloud when connected)